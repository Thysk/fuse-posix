/*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Copyright European Organization for Nuclear Research (CERN)
Licensed under the Apache License, Version 2.0 (the "License");
You may not use this file except in compliance with the License.
You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
Authors:
 - Gabriele Gaetano Fronz√©, <gfronze@cern.ch>, 2019-2020
/*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef RUCIO_FUSE_POSIX_DOWNLOAD_CACHE_H
#define RUCIO_FUSE_POSIX_DOWNLOAD_CACHE_H

#include <unordered_map>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This struct implements a did to local cache path mapping.
// It also keeps open files pointer alive and performs cleanup at end of execution.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct file_cache {
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // An unordered_map serving as local cache for open files as well
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    std::unordered_map<std::string, FILE*> cache;

    //TODO-or-NOT: here we can populate the cache at startup parsing all files in the cache root.
    file_cache() = default;

    ~file_cache(){
      for(auto &file : cache){
        if(file.second){
          fclose(file.second);
        }
      }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Returns true if file is cached
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    bool is_cached(const std::string& key){
      return cache.find(key) != cache.end();
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Returns a valid file pointer if file is cached
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FILE* get_file(const std::string& key){
      return (is_cached(key))?cache[key]:nullptr;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Registers a new file in the cache via file pointer
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    bool add_file(const std::string& key, FILE* file){
      cache[key] = file;
      return true;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Registers a new file in the cache via the path string
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    bool add_file(std::string key){
      cache[key] = fopen(key.data(), "rb");
      return true;
    }
};

static file_cache rucio_download_cache;

#endif //RUCIO_FUSE_POSIX_DOWNLOAD_CACHE_H
